<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>怎么理解js中函数是一等公民</title>
      <link href="/c08ec216fed2/"/>
      <url>/c08ec216fed2/</url>
      
        <content type="html"><![CDATA[<p>将函数视为“一等公民”（First-Class Citizens）意味着在JavaScript中，函数被视为与其他数据类型相同，可以像变量、对象和其他数据类型一样进行操作和使用。这种特性在编程语言中通常被称为“一等函数”或“函数作为一等公民”。以下是理解JavaScript中函数作为一等公民的几个关键点：</p><ol><li><p><strong>函数可以被赋值给变量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，一个函数袂被赋值给了变量<code>add</code>，从而可以像操作其他变量一样操作函数。</p></li><li><p><strong>函数可以作为参数传递</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里调用传递进来的函数</span></span><br><span class="line">  <span class="title function_">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Doing something...&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以将函数直接传递给另一个函数，并在其中执行。</p></li><li><p><strong>函数可以作为返回值</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGreeter</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> greetInEnglish = <span class="title function_">createGreeter</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="title function_">greetInEnglish</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>createGreeter</code>函数返回另一个函数，这个返回的函数在调用时打印相应的问候语，闭包就是这么实现的。</p></li><li><p><strong>函数可以存储在数据结构中</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> functions = [<span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b; &#125;, <span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a - b; &#125;];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(functions[<span class="number">0</span>](<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure><p>在这个例子中，函数存储在数组中，并可以像其他数据一样进行访问和使用，当然这种用法比较少，因为不符合我们的编程习惯</p></li></ol><p>JavaScript中的函数是一等公民意味着函数在语言中具有与其他数据类型相同的地位，可以自由地赋值、传递、返回和存储。这种特性使得JavaScript可以以更灵活的方式编写代码，并支持函数式编程的范式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的作用域，以及js为什么需要绑定this</title>
      <link href="/f2ae2a403256/"/>
      <url>/f2ae2a403256/</url>
      
        <content type="html"><![CDATA[<p>JavaScript有两种主要的作用域：全局作用域和局部作用域。全局作用域是代码中任何地方都可以访问的范围，而局部作用域是指仅在特定代码块内部可见的范围。JavaScript在设计上需要绑定<code>this</code>关键字是因为其函数作用域和对象导向的特性。</p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><ul><li><p>**全局作用域(Global Scope)**：全局作用域中声明的变量和函数可以被整个代码访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">globalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 可以访问globalVariable</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVariable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**局部作用域(Local Scope)**：局部作用域中声明的变量和函数只能在其声明的代码块内部访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">localFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> localVariable = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 只能在localFunction内部访问localVariable</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(localVariable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>JavaScript的作用域是通过函数来创建的，每个函数都有自己的作用域，这样可以隔离变量，避免命名冲突和数据混乱。</p><h3 id="绑定this"><a href="#绑定this" class="headerlink" title="绑定this"></a>绑定this</h3><p>JavaScript中的<code>this</code>关键字在不同的情况下指向不同的值，它可以指向调用它的对象，也可以通过显示绑定来指向指定的对象。绑定<code>this</code>的主要原因是 JavaScript 是一门多范式的语言，可以同时支持面向对象编程、函数式编程等多种范式。在不同的编程范式中，对<code>this</code>的使用和指向有不同的约定和规则。</p><ul><li><p><strong>面向对象编程</strong>：在使用类、对象和原型继承构建对象时，需要通过<code>this</code>关键字来引用对象的属性和方法。</p></li><li><p><strong>函数式编程</strong>：在函数式编程范式中，需要让函数能够在不同的上下文中正确地执行，因此需要对<code>this</code>进行正确的绑定，以确保它在函数内部指向预期的值。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nest&quot;拦截器&quot;,&quot;验证器&quot;,&quot;中间件&quot;的区别</title>
      <link href="/29f70be0c3d2/"/>
      <url>/29f70be0c3d2/</url>
      
        <content type="html"><![CDATA[<p>在Nest.js中，拦截器(interceptor)、验证器(validator)和中间件(middleware)是三种不同的概念，它们分别用于不同的场景和目的。</p><ol><li><p>拦截器(interceptor)：</p><ul><li>拦截器用于在处理请求的过程中拦截和处理HTTP请求和响应。拦截器可以在处理请求之前或之后执行额外的逻辑。它可以修改请求、响应或异常的行为，从而实现对请求和响应的统一处理和控制。</li><li>示例：一个日志拦截器可以在处理请求之前和之后分别记录请求的信息和响应的结果，用于统一日志记录和跟踪。</li></ul></li><li><p>验证器(validator)：</p><ul><li>验证器通常用于验证用户提交的数据，例如表单数据、API请求参数等。在Nest.js中，可以使用类验证器(class-validator)库或自定义验证器来实现对数据的验证和校验，以确保数据的有效性和完整性。</li><li>示例：一个用户注册的验证器可以对用户提交的注册信息进行验证，包括邮箱格式、密码规则等。</li></ul></li><li><p>中间件(middleware)：</p><ul><li>中间件是一个函数，它可以在请求处理管道中执行额外的逻辑，例如身份验证、日志记录、错误处理等。中间件可以用于全局范围或特定路由范围的请求处理。</li><li>示例：一个身份验证中间件可以在处理请求之前验证用户的身份，并决定是否允许继续请求的处理。</li></ul></li></ol><h3 id="拦截器-interceptor-示例："><a href="#拦截器-interceptor-示例：" class="headerlink" title="拦截器(interceptor)示例："></a>拦截器(interceptor)示例：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">NestInterceptor</span>, <span class="title class_">ExecutionContext</span>, <span class="title class_">CallHandler</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Observable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title class_">NestInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">// 实现intercept方法</span></span><br><span class="line">  <span class="title function_">intercept</span>(<span class="attr">context</span>: <span class="title class_">ExecutionContext</span>, <span class="attr">next</span>: <span class="title class_">CallHandler</span>): <span class="title class_">Observable</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 在处理请求之前输出日志</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Before...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 记录当前时间</span></span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 处理请求，并在处理完后输出日志，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">      .<span class="title function_">handle</span>()</span><br><span class="line">      .<span class="title function_">pipe</span>(</span><br><span class="line">        <span class="title function_">map</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 在处理请求后输出日志，并记录时间差</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`After... <span class="subst">$&#123;<span class="built_in">Date</span>.now() - now&#125;</span>ms`</span>);</span><br><span class="line">          <span class="keyword">return</span> data; <span class="comment">// 返回处理后的数据</span></span><br><span class="line">        &#125;),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证器-validator-示例："><a href="#验证器-validator-示例：" class="headerlink" title="验证器(validator)示例："></a>验证器(validator)示例：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IsEmail</span>, <span class="title class_">IsNotEmpty</span>, <span class="title class_">MaxLength</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;class-validator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CreateUserDto</span> &#123;</span><br><span class="line">  <span class="meta">@IsEmail</span>() <span class="comment">// 邮箱格式验证</span></span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IsNotEmpty</span>() <span class="comment">// 不为空验证</span></span><br><span class="line">  <span class="meta">@MaxLength</span>(<span class="number">20</span>) <span class="comment">// 最大长度验证</span></span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个用户注册信息的数据传输对象(DTO)，通过使用 class-validator 库中的装饰器对提交的数据进行验证，确保邮箱格式和密码规则的有效性。</p><h3 id="中间件-middleware-示例："><a href="#中间件-middleware-示例：" class="headerlink" title="中间件(middleware)示例："></a>中间件(middleware)示例：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">NestMiddleware</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Request</span>, <span class="title class_">Response</span>, <span class="title class_">NextFunction</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LoggerMiddleware</span> <span class="keyword">implements</span> <span class="title class_">NestMiddleware</span> &#123;</span><br><span class="line">  <span class="comment">// 实现 use 方法</span></span><br><span class="line">  <span class="title function_">use</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) &#123;</span><br><span class="line">    <span class="comment">// 在处理请求前输出日志</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request...&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>(); <span class="comment">// 调用下一个中间件或路由处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ts高级功能&quot;装饰器&quot;</title>
      <link href="/fcdd2c3b9807/"/>
      <url>/fcdd2c3b9807/</url>
      
        <content type="html"><![CDATA[<p>Typescript装饰器是一种特殊类型的声明，可以附加到类、方法、访问符、属性或参数上，通过装饰器可以对这些元素进行各种操作和修改。装饰器使用<code>@</code>符号，后跟一个函数或类，用来实现对类行为的改变。</p><h2 id="装饰器的用法"><a href="#装饰器的用法" class="headerlink" title="装饰器的用法"></a>装饰器的用法</h2><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器是一个函数，它可以被附加到类构造函数上，用来监视、修改或替换类定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logClass</span>(<span class="params">target: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@logClass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am a person&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器应用于一个类的方法属性描述符上，可以用来监视、修改或替换方法定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logMethod</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; was called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="meta">@logMethod</span></span><br><span class="line">    <span class="title function_">square</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器表达式在运行时被调用，可以用来监视、修改或替换类的属性定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; was called&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@logProperty</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器的原理"><a href="#装饰器的原理" class="headerlink" title="装饰器的原理"></a>装饰器的原理</h2><p>Typescript装饰器是基于ECMAScript 6的一个特性，它通过修改类的行为实现了细粒度的控制和修改。装饰器在编译期被调用，并通过装饰器工厂返回一个表达式函数，然后被应用到类、方法或属性上面。</p><p>装饰器原理涉及元编程的概念，通过装饰器可以动态修改或扩展类的行为。在应用装饰器时，装饰器工厂函数被调用并返回一个表达式函数，该函数在运行时被调用，从而实现对类行为的改变。</p><p>Typescript装饰器极大地提高了代码的可读性和维护性，同时也为开发者提供了更大的灵活性。装饰器是Typescript中一个非常强大且重要的特性，可以帮助开发者更好地管理和组织代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
